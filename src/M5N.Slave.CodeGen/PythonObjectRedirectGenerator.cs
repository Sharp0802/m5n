using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace M5N.Slave.CodeGen;

[Generator]
public class PythonObjectRedirectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
                              .CreateSyntaxProvider(
                                  (s,   _) => s is ClassDeclarationSyntax,
                                  (ctx, _) => (ClassDeclarationSyntax)ctx.Node);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static void GenerateCode(
        SourceProductionContext                context,
        Compilation                            compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        var main = new StringBuilder();
        var sub  = new StringBuilder();
        
        main.Append(
            """
            // <auto-generated/>
            
            using System.Runtime.InteropServices;
            
            namespace M5N.Slave.Interop.Dynamics;
            
            public partial class PythonObject
            {
            
            """);
        
        sub.AppendLine(
            """
                public static PythonObject FromHandle(IntPtr handle)
                {
                    if (handle == GetAddressOfNoneObject())
                        return null;
                        
            """);
        
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semantic = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semantic.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;
            if (!"PythonObject".Equals(classSymbol.BaseType?.Name, StringComparison.Ordinal))
                continue;

            var decl = classSymbol.AllInterfaces.First(symbol =>
                symbol.Name.StartsWith("IPythonObject") &&
                symbol.TypeArguments.Length == 2);

            var managedTypeSymbol = decl.TypeArguments[0].ToDisplayString();

            main.AppendLine(
                $$"""
                      public static implicit operator PythonObject({{managedTypeSymbol}} raw) => 
                          ({{classSymbol.ToDisplayString()}})raw;
                          
                      [DllImport(InteropConfiguration.FnExports)]
                      internal static extern int IsType_{{classSymbol.Name}}(IntPtr v);
                      
                  """);

            sub.AppendLine(
                $$"""
                          if (IsType_{{classSymbol.Name}}(handle) != 0)
                              return ({{classSymbol.ToDisplayString()}})handle;
                  """);
        }

        main.Append(sub).AppendLine(
            """
            
                    throw new NotSupportedException();
                }
            }
            """);
        
        context.AddSource("PythonObject.g.cs", SourceText.From(main.ToString(), Encoding.UTF8));
    }
}